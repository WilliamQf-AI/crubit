// Part of the Crubit project, under the Apache License v2.0 with LLVM
// Exceptions. See /LICENSE for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

use crate::std::string_view;
use core::ptr;

impl From<string_view> for *const [u8] {
    fn from(sv: string_view) -> Self {
        let mut data = unsafe { string_view::data(&sv) };
        // TODO(b/249376862): use size.
        // let size = unsafe {string_view::size(&sv)};
        let size = unsafe { string_view::end(&sv) as usize - string_view::begin(&sv) as usize };
        // Unlike C++, Rust does not allow for null data pointers in slices.
        if data.is_null() {
            data = ptr::NonNull::dangling().as_ptr();
            debug_assert_eq!(size, 0);
        }
        ptr::slice_from_raw_parts(data, size)
    }
}
impl From<&[u8]> for string_view {
    fn from(s: &[u8]) -> Self {
        string_view::from(s as *const [u8])
    }
}

impl From<&str> for string_view {
    fn from(s: &str) -> Self {
        string_view::from(s.as_bytes())
    }
}

impl From<&core::ffi::CStr> for string_view {
    fn from(cstr: &core::ffi::CStr) -> Self {
        string_view::from(cstr.to_bytes())
    }
}

impl From<*const [u8]> for string_view {
    fn from(slice: *const [u8]) -> Self {
        // No stable way to do this per se, but the UCG documents this transmute is OK.
        // An RFC is in the works to officially stabilize this. It is expected
        // to be noncontroversial.
        //
        // See:
        //
        // * UCG: https://rust-lang.github.io/unsafe-code-guidelines/layout/pointers.html
        // * Zulip: https://rust-lang.zulipchat.com/#narrow/stream/213817-t-lang/topic/Can.20we.20stabilize.20the.20layout.20of.20.26.5BT.5D.20and.20.26str.3F/near/394683395
        //
        // We could also use the (unstable) to_raw_parts, but that feature may change
        // over time. It's also difficult, for idiosyncratic reasons, to pipe in
        // the feature flag to the automatically generated bindings for
        // `string_view` that this file attaches onto, or to inject a dependency
        // on a crate to put this logic into. (The crate this file is a part of is
        // automatically generated by Crubit, and so we would need to tell
        // Crubit to add these to the generated bindings for `std`.) So for now,
        // the most expedient thing, and the thing least likely to break in a
        // future version of Rust, is transmute.

        #[allow(dead_code)]
        #[repr(C)]
        struct RawSlice(*const u8, usize);
        let RawSlice(ptr, size) = unsafe { core::mem::transmute(slice) };
        let ptr = if size == 0 { 0 as *const _ } else { ptr };

        // TODO(jeanpierreda): We can't access the constructors at the moment.
        // This little maneuver's gonna cost us 51 years of annoying build breakages
        // later, so really we should try to get the constructors callable.
        unsafe {
            let mut sv = <core::mem::MaybeUninit<string_view>>::zeroed().assume_init();
            sv.__data_ = core::mem::transmute(ptr);
            sv.__size_ = core::mem::transmute(size);
            sv
        }
    }
}
